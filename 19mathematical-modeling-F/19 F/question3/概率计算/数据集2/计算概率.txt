1.	首先建立一个2^n行，n+3列的矩阵e，每一列对应着2^n种可能性，第一列和第二列分别存储当前的水平和垂直误差，第三列是当前情况是否丢失的标志，1为丢失，之后的每列为单次的选择概率集合。
e()

e(1,:)=[0, 0，0,];

for1 i=1: N  %经过的总的校正点数
	
	row=size(e(:,1)) %当前行数，即已经有的可能数,
	
	for2 j=1:row %当前行数
		if e(j,3)！=1 %没有丢失
			e(j,1)=（校正点N-上一校正点)/tetha + e(j,1);
			e(j,2)=（校正点N-上一校正点)/tetha + e(j,2);  %更新水平和垂直误差
			根据校正点的限制判断是否能在当前点完成校正；
			if 不能校正，即丢失，e(j,3)=1；
		endif
	endfor2	

	
			if 校正点i是水平校正点
			
				if 当前校正点类型是1，即可能校正失败的点
					
					for3 z=1:row  %当前的行数
						把当前的矩阵复制一份，加在后面，即 e(z+size(e(:,1)),:)=e(z,:);	
					endfor3
					
					for4 p = 1：row  
						e(p,size(e(1,:))+1)=0.8 %在p行的最后加一个0.8，表示是成功校正
						if e( p，3）！= 1 %没有丢失
							e(p,1) = 0;  %校正水平误差
						endif
					endfor4
					
					for5 p = row ：2row 
						e(p,size(e(1,:))+1)=0.2 %在p行的最后加一个0.2，表示是失败校正
						if e( p，3）！=1 %没有丢失
						e(p,1) =min(5,e(p,1));  %失败校正水平误差
					endfor5
					
				else  %不是类型1的点，即能成功校正的点
					e(p,1) = 0;  %校正水平误差
				endif
			endif

			if 校正点i是垂直校正点
				
				if 当前校正点类型是1，即可能校正失败的点
					
					for3 z=1:row  %当前的行数
						把当前的矩阵复制一份，加在后面，即 e(z+size(e(:,1)),:)=e(z,:);	
					endfor3
					
					for4 p = 1 ：row  
						e(p,size(e(1,:))+1)=0.8 %在p行的最后加一个0.8，表示是成功校正
						if e( p，3）！=1 %没有丢失
							e(p,1) = 0;  %校正水平误差
						endif
					endfor4
					
					for5 p = row ：2row 
						e(p,size(e(1,:))+1)=0.2 %在p行的最后加一个0.2，表示是失败校正
						if e( p，3）！=1 %没有丢失
						e(p,1) =min(5,e(p,1));  %失败校正水平误差
					endfor5
				else  %不是类型1的点，即能成功校正的点
					e(p,1) = 0;  %校正水平误差
				endif
			endif

endfor1

取矩阵e中所有丢失标志为1的行，丢失的总概率=每行选择概率乘积的和。
同时可以算一下所有函数的概率和加起来是否为1。
